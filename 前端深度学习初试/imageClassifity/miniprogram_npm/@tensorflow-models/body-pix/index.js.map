{"version":3,"sources":["index.js","body_pix_model.js","decode_part_map.js","mobilenet.js","base_model.js","multi_person/decode_instance_masks.js","multi_person/decode_multiple_masks_cpu.js","keypoints.js","multi_person/util.js","multi_person/decode_multiple_masks_webgl.js","multi_person/decode_multiple_poses.js","multi_person/build_part_with_score_queue.js","multi_person/max_heap.js","multi_person/decode_pose.js","resnet.js","saved_models.js","util.js","output_rendering_util.js","blur.js","part_channels.js","version.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA;ACFA,AHSA,ACHA,AFMA,AGTA,AENA;ADIA,AHSA,ACHA,AFMA,AGTA,AENA;ADIA,AHSA,ACHA,AFMA,AGTA,AENA;ADIA,AHSA,ACHA,AFMA,AGTA,AENA,ACHA;AFOA,AHSA,ACHA,AFMA,AGTA,AENA,ACHA;AFOA,AHSA,ACHA,AFMA,AGTA,AENA,ACHA;AFOA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA;AFOA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA;AFOA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA;AFOA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AENA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AENA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AENA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AGTA,ADGA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AGTA,ADGA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AGTA,ADGA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AGTA,ACHA,AFMA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AGTA,ACHA,AFMA;AJaA,AHSA,ACHA,AKfA,AJYA,AENA,ACHA,AGTA,ACHA,AFMA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AFMA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AFMA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AFMA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AENA,AJYA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AENA,AJYA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AENA,AJYA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA;AJaA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA;AV+BA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA;AV+BA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA;AV+BA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA,ACHA;AXkCA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA,ACHA;AXkCA,AHSA,ACHA,AKfA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA,ACHA;AXkCA,AHSA,AMlBA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA,ACHA,ACHA;AZqCA,AHSA,AMlBA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA,ACHA,ACHA;Af8CA,AMlBA,AJYA,AQxBA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AMlBA,ACHA,ACHA;Af8CA,AMlBA,AIZA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AHSA,ACHA,ACHA;Af8CA,AMlBA,AIZA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AHSA,ACHA,ACHA;Af8CA,AMlBA,AIZA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AHSA,ACHA,ACHA;AELA,AjBmDA,AMlBA,AIZA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AHSA,ACHA,ACHA;AELA,AjBmDA,AMlBA,AIZA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AHSA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AHSA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,AjBmDA,AU9BA,ANkBA,ACHA,AGTA,ACHA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA,AIZA;AFOA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,ACHA,ACHA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AIZA,AGTA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;AELA,AjBmDA,AU9BA,ANkBA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,ALeA,AENA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AJYA,AS3BA,AENA,AHSA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,AENA,AHSA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,ADGA,AKfA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AOrBA,AIZA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,ACHA,AWjCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AIZA,AYpCA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA,ADGA;Af8CA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA,AgBhDA;AhBiDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar body_pix_model_1 = require(\"./body_pix_model\");\nexports.BodyPix = body_pix_model_1.BodyPix;\nexports.load = body_pix_model_1.load;\nvar output_rendering_util_1 = require(\"./output_rendering_util\");\nexports.blurBodyPart = output_rendering_util_1.blurBodyPart;\nexports.drawBokehEffect = output_rendering_util_1.drawBokehEffect;\nexports.drawMask = output_rendering_util_1.drawMask;\nexports.drawPixelatedMask = output_rendering_util_1.drawPixelatedMask;\nexports.toColoredPartMask = output_rendering_util_1.toColoredPartMask;\nexports.toMask = output_rendering_util_1.toMask;\nvar part_channels_1 = require(\"./part_channels\");\nexports.PART_CHANNELS = part_channels_1.PART_CHANNELS;\nvar util_1 = require(\"./util\");\nexports.flipPoseHorizontal = util_1.flipPoseHorizontal;\nexports.resizeAndPadTo = util_1.resizeAndPadTo;\nexports.scaleAndCropToInputTensorShape = util_1.scaleAndCropToInputTensorShape;\nvar version_1 = require(\"./version\");\nexports.version = version_1.version;\n//# sourceMappingURL=index.js.map","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfconv = require(\"@tensorflow/tfjs-converter\");\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar decode_part_map_1 = require(\"./decode_part_map\");\nvar mobilenet_1 = require(\"./mobilenet\");\nvar decode_instance_masks_1 = require(\"./multi_person/decode_instance_masks\");\nvar decode_multiple_poses_1 = require(\"./multi_person/decode_multiple_poses\");\nvar resnet_1 = require(\"./resnet\");\nvar saved_models_1 = require(\"./saved_models\");\nvar util_1 = require(\"./util\");\nvar APPLY_SIGMOID_ACTIVATION = true;\nvar FLIP_POSES_AFTER_SCALING = false;\nvar MOBILENET_V1_CONFIG = {\n    architecture: 'MobileNetV1',\n    outputStride: 16,\n    quantBytes: 4,\n    multiplier: 0.75,\n};\nvar VALID_ARCHITECTURE = ['MobileNetV1', 'ResNet50'];\nvar VALID_STRIDE = {\n    'MobileNetV1': [8, 16, 32],\n    'ResNet50': [32, 16]\n};\nvar VALID_MULTIPLIER = {\n    'MobileNetV1': [0.50, 0.75, 1.0],\n    'ResNet50': [1.0]\n};\nvar VALID_QUANT_BYTES = [1, 2, 4];\nfunction validateModelConfig(config) {\n    config = config || MOBILENET_V1_CONFIG;\n    if (config.architecture == null) {\n        config.architecture = 'MobileNetV1';\n    }\n    if (VALID_ARCHITECTURE.indexOf(config.architecture) < 0) {\n        throw new Error(\"Invalid architecture \" + config.architecture + \". \" +\n            (\"Should be one of \" + VALID_ARCHITECTURE));\n    }\n    if (config.outputStride == null) {\n        config.outputStride = 16;\n    }\n    if (VALID_STRIDE[config.architecture].indexOf(config.outputStride) < 0) {\n        throw new Error(\"Invalid outputStride \" + config.outputStride + \". \" +\n            (\"Should be one of \" + VALID_STRIDE[config.architecture] + \" \") +\n            (\"for architecture \" + config.architecture + \".\"));\n    }\n    if (config.multiplier == null) {\n        config.multiplier = 1.0;\n    }\n    if (VALID_MULTIPLIER[config.architecture].indexOf(config.multiplier) < 0) {\n        throw new Error(\"Invalid multiplier \" + config.multiplier + \". \" +\n            (\"Should be one of \" + VALID_MULTIPLIER[config.architecture] + \" \") +\n            (\"for architecture \" + config.architecture + \".\"));\n    }\n    if (config.quantBytes == null) {\n        config.quantBytes = 4;\n    }\n    if (VALID_QUANT_BYTES.indexOf(config.quantBytes) < 0) {\n        throw new Error(\"Invalid quantBytes \" + config.quantBytes + \". \" +\n            (\"Should be one of \" + VALID_QUANT_BYTES + \" \") +\n            (\"for architecture \" + config.architecture + \".\"));\n    }\n    return config;\n}\nexports.PERSON_INFERENCE_CONFIG = {\n    flipHorizontal: false,\n    internalResolution: 'medium',\n    segmentationThreshold: 0.7,\n    maxDetections: 10,\n    scoreThreshold: 0.4,\n    nmsRadius: 20,\n};\nexports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG = {\n    flipHorizontal: false,\n    internalResolution: 'medium',\n    segmentationThreshold: 0.7,\n    maxDetections: 10,\n    scoreThreshold: 0.4,\n    nmsRadius: 20,\n    minKeypointScore: 0.3,\n    refineSteps: 10\n};\nfunction validatePersonInferenceConfig(config) {\n    var segmentationThreshold = config.segmentationThreshold, maxDetections = config.maxDetections, scoreThreshold = config.scoreThreshold, nmsRadius = config.nmsRadius;\n    if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n        throw new Error(\"segmentationThreshold \" + segmentationThreshold + \". \" +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (maxDetections <= 0) {\n        throw new Error(\"Invalid maxDetections \" + maxDetections + \". \" +\n            \"Should be > 0\");\n    }\n    if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n        throw new Error(\"Invalid scoreThreshold \" + scoreThreshold + \". \" +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (nmsRadius <= 0) {\n        throw new Error(\"Invalid nmsRadius \" + nmsRadius + \".\");\n    }\n}\nfunction validateMultiPersonInstanceInferenceConfig(config) {\n    var segmentationThreshold = config.segmentationThreshold, maxDetections = config.maxDetections, scoreThreshold = config.scoreThreshold, nmsRadius = config.nmsRadius, minKeypointScore = config.minKeypointScore, refineSteps = config.refineSteps;\n    if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n        throw new Error(\"segmentationThreshold \" + segmentationThreshold + \". \" +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (maxDetections <= 0) {\n        throw new Error(\"Invalid maxDetections \" + maxDetections + \". \" +\n            \"Should be > 0\");\n    }\n    if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n        throw new Error(\"Invalid scoreThreshold \" + scoreThreshold + \". \" +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (nmsRadius <= 0) {\n        throw new Error(\"Invalid nmsRadius \" + nmsRadius + \".\");\n    }\n    if (minKeypointScore < 0 || minKeypointScore > 1) {\n        throw new Error(\"Invalid minKeypointScore \" + minKeypointScore + \".\" +\n            \"Should be in range [0.0, 1.0]\");\n    }\n    if (refineSteps <= 0 || refineSteps > 20) {\n        throw new Error(\"Invalid refineSteps \" + refineSteps + \".\" +\n            \"Should be in range [1, 20]\");\n    }\n}\nvar BodyPix = (function () {\n    function BodyPix(net) {\n        this.baseModel = net;\n    }\n    BodyPix.prototype.predictForPersonSegmentation = function (input) {\n        var _a = this.baseModel.predict(input), segmentation = _a.segmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n        return {\n            segmentLogits: segmentation,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n        };\n    };\n    BodyPix.prototype.predictForPersonSegmentationAndPart = function (input) {\n        var _a = this.baseModel.predict(input), segmentation = _a.segmentation, partHeatmaps = _a.partHeatmaps, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n        return {\n            segmentLogits: segmentation,\n            partHeatmapLogits: partHeatmaps,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n        };\n    };\n    BodyPix.prototype.predictForMultiPersonInstanceSegmentationAndPart = function (input) {\n        var _a = this.baseModel.predict(input), segmentation = _a.segmentation, longOffsets = _a.longOffsets, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, partHeatmaps = _a.partHeatmaps;\n        return {\n            segmentLogits: segmentation,\n            longOffsets: longOffsets,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            partHeatmaps: partHeatmaps\n        };\n    };\n    BodyPix.prototype.segmentPersonActivation = function (input, internalResolution, segmentationThreshold) {\n        var _this = this;\n        if (segmentationThreshold === void 0) { segmentationThreshold = 0.5; }\n        var _a = util_1.getInputSize(input), height = _a[0], width = _a[1];\n        var internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);\n        var _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n        var _c = tf.tidy(function () {\n            var _a = _this.predictForPersonSegmentation(resized), segmentLogits = _a.segmentLogits, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n            var _b = resized.shape, resizedHeight = _b[0], resizedWidth = _b[1];\n            var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n            return {\n                segmentation: decode_part_map_1.toMaskTensor(scaledSegmentScores.squeeze(), segmentationThreshold),\n                heatmapScores: heatmapScores,\n                offsets: offsets,\n                displacementFwd: displacementFwd,\n                displacementBwd: displacementBwd,\n            };\n        }), segmentation = _c.segmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;\n        resized.dispose();\n        return {\n            segmentation: segmentation,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            padding: padding,\n            internalResolutionHeightAndWidth: internalResolutionHeightAndWidth\n        };\n    };\n    BodyPix.prototype.segmentPerson = function (input, config) {\n        if (config === void 0) { config = exports.PERSON_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, segmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, result, _c, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        config = __assign({}, exports.PERSON_INFERENCE_CONFIG, config);\n                        validatePersonInferenceConfig(config);\n                        _a = this.segmentPersonActivation(input, config.internalResolution, config.segmentationThreshold), segmentation = _a.segmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, padding = _a.padding, internalResolutionHeightAndWidth = _a.internalResolutionHeightAndWidth;\n                        _b = segmentation.shape, height = _b[0], width = _b[1];\n                        return [4, segmentation.data()];\n                    case 1:\n                        result = _d.sent();\n                        segmentation.dispose();\n                        return [4, util_1.toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];\n                    case 2:\n                        _c = _d.sent(), scoresBuf = _c[0], offsetsBuf = _c[1], displacementsFwdBuf = _c[2], displacementsBwdBuf = _c[3];\n                        poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        heatmapScores.dispose();\n                        offsets.dispose();\n                        displacementFwd.dispose();\n                        displacementBwd.dispose();\n                        return [2, { height: height, width: width, data: result, allPoses: poses }];\n                }\n            });\n        });\n    };\n    BodyPix.prototype.segmentMultiPerson = function (input, config) {\n        if (config === void 0) { config = exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, _d, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;\n            var _this = this;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        config = __assign({}, exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, config);\n                        validateMultiPersonInstanceInferenceConfig(config);\n                        _a = util_1.getInputSize(input), height = _a[0], width = _a[1];\n                        internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(config.internalResolution, this.baseModel.outputStride, [height, width]);\n                        _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n                        _c = tf.tidy(function () {\n                            var _a = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a.segmentLogits, longOffsets = _a.longOffsets, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n                            var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n                            var longOffsetsResized = false;\n                            var scaledLongOffsets;\n                            if (longOffsetsResized) {\n                                scaledLongOffsets = util_1.scaleAndCropToInputTensorShape(longOffsets, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n                            }\n                            else {\n                                scaledLongOffsets = longOffsets;\n                            }\n                            var segmentation = decode_part_map_1.toMaskTensor(scaledSegmentScores.squeeze(), config.segmentationThreshold);\n                            return {\n                                segmentation: segmentation,\n                                longOffsets: scaledLongOffsets,\n                                heatmapScoresRaw: heatmapScores,\n                                offsetsRaw: offsets,\n                                displacementFwdRaw: displacementFwd,\n                                displacementBwdRaw: displacementBwd,\n                            };\n                        }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw;\n                        return [4, util_1.toTensorBuffers3D([\n                                heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw\n                            ])];\n                    case 1:\n                        _d = _e.sent(), scoresBuf = _d[0], offsetsBuf = _d[1], displacementsFwdBuf = _d[2], displacementsBwdBuf = _d[3];\n                        poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        return [4, decode_instance_masks_1.decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config.scoreThreshold, config.refineSteps, config.minKeypointScore, config.maxDetections)];\n                    case 2:\n                        instanceMasks = _e.sent();\n                        resized.dispose();\n                        segmentation.dispose();\n                        longOffsets.dispose();\n                        heatmapScoresRaw.dispose();\n                        offsetsRaw.dispose();\n                        displacementFwdRaw.dispose();\n                        displacementBwdRaw.dispose();\n                        return [2, instanceMasks];\n                }\n            });\n        });\n    };\n    BodyPix.prototype.segmentPersonPartsActivation = function (input, internalResolution, segmentationThreshold) {\n        var _this = this;\n        if (segmentationThreshold === void 0) { segmentationThreshold = 0.5; }\n        var _a = util_1.getInputSize(input), height = _a[0], width = _a[1];\n        var internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);\n        var _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n        var _c = tf.tidy(function () {\n            var _a = _this.predictForPersonSegmentationAndPart(resized), segmentLogits = _a.segmentLogits, partHeatmapLogits = _a.partHeatmapLogits, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd;\n            var _b = resized.shape, resizedHeight = _b[0], resizedWidth = _b[1];\n            var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n            var scaledPartHeatmapScore = util_1.scaleAndCropToInputTensorShape(partHeatmapLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n            var segmentation = decode_part_map_1.toMaskTensor(scaledSegmentScores.squeeze(), segmentationThreshold);\n            return {\n                partSegmentation: decode_part_map_1.decodePartSegmentation(segmentation, scaledPartHeatmapScore),\n                heatmapScores: heatmapScores,\n                offsets: offsets,\n                displacementFwd: displacementFwd,\n                displacementBwd: displacementBwd,\n            };\n        }), partSegmentation = _c.partSegmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;\n        resized.dispose();\n        return {\n            partSegmentation: partSegmentation,\n            heatmapScores: heatmapScores,\n            offsets: offsets,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            padding: padding,\n            internalResolutionHeightAndWidth: internalResolutionHeightAndWidth\n        };\n    };\n    BodyPix.prototype.segmentPersonParts = function (input, config) {\n        if (config === void 0) { config = exports.PERSON_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, partSegmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, data, _c, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        config = __assign({}, exports.PERSON_INFERENCE_CONFIG, config);\n                        validatePersonInferenceConfig(config);\n                        _a = this.segmentPersonPartsActivation(input, config.internalResolution, config.segmentationThreshold), partSegmentation = _a.partSegmentation, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, padding = _a.padding, internalResolutionHeightAndWidth = _a.internalResolutionHeightAndWidth;\n                        _b = partSegmentation.shape, height = _b[0], width = _b[1];\n                        return [4, partSegmentation.data()];\n                    case 1:\n                        data = _d.sent();\n                        partSegmentation.dispose();\n                        return [4, util_1.toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];\n                    case 2:\n                        _c = _d.sent(), scoresBuf = _c[0], offsetsBuf = _c[1], displacementsFwdBuf = _c[2], displacementsBwdBuf = _c[3];\n                        poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        heatmapScores.dispose();\n                        offsets.dispose();\n                        displacementFwd.dispose();\n                        displacementBwd.dispose();\n                        return [2, { height: height, width: width, data: data, allPoses: poses }];\n                }\n            });\n        });\n    };\n    BodyPix.prototype.segmentMultiPersonParts = function (input, config) {\n        if (config === void 0) { config = exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, partSegmentation, _d, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;\n            var _this = this;\n            return __generator(this, function (_e) {\n                switch (_e.label) {\n                    case 0:\n                        config = __assign({}, exports.MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, config);\n                        validateMultiPersonInstanceInferenceConfig(config);\n                        _a = util_1.getInputSize(input), height = _a[0], width = _a[1];\n                        internalResolutionHeightAndWidth = util_1.toInputResolutionHeightAndWidth(config.internalResolution, this.baseModel.outputStride, [height, width]);\n                        _b = util_1.padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;\n                        _c = tf.tidy(function () {\n                            var _a = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a.segmentLogits, longOffsets = _a.longOffsets, heatmapScores = _a.heatmapScores, offsets = _a.offsets, displacementFwd = _a.displacementFwd, displacementBwd = _a.displacementBwd, partHeatmaps = _a.partHeatmaps;\n                            var scaledSegmentScores = util_1.scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n                            var scaledPartSegmentationScores = util_1.scaleAndCropToInputTensorShape(partHeatmaps, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]], APPLY_SIGMOID_ACTIVATION);\n                            var scaledLongOffsets = longOffsets;\n                            var segmentation = decode_part_map_1.toMaskTensor(scaledSegmentScores.squeeze(), config.segmentationThreshold);\n                            var partSegmentation = decode_part_map_1.decodeOnlyPartSegmentation(scaledPartSegmentationScores);\n                            return {\n                                segmentation: segmentation,\n                                longOffsets: scaledLongOffsets,\n                                heatmapScoresRaw: heatmapScores,\n                                offsetsRaw: offsets,\n                                displacementFwdRaw: displacementFwd,\n                                displacementBwdRaw: displacementBwd,\n                                partSegmentation: partSegmentation\n                            };\n                        }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw, partSegmentation = _c.partSegmentation;\n                        return [4, util_1.toTensorBuffers3D([\n                                heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw\n                            ])];\n                    case 1:\n                        _d = _e.sent(), scoresBuf = _d[0], offsetsBuf = _d[1], displacementsFwdBuf = _d[2], displacementsBwdBuf = _d[3];\n                        poses = decode_multiple_poses_1.decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config.maxDetections, config.scoreThreshold, config.nmsRadius);\n                        poses = util_1.scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding, FLIP_POSES_AFTER_SCALING);\n                        return [4, decode_instance_masks_1.decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config.scoreThreshold, config.refineSteps, config.minKeypointScore, config.maxDetections)];\n                    case 2:\n                        instanceMasks = _e.sent();\n                        resized.dispose();\n                        segmentation.dispose();\n                        longOffsets.dispose();\n                        heatmapScoresRaw.dispose();\n                        offsetsRaw.dispose();\n                        displacementFwdRaw.dispose();\n                        displacementBwdRaw.dispose();\n                        partSegmentation.dispose();\n                        return [2, instanceMasks];\n                }\n            });\n        });\n    };\n    BodyPix.prototype.dispose = function () {\n        this.baseModel.dispose();\n    };\n    return BodyPix;\n}());\nexports.BodyPix = BodyPix;\nfunction loadMobileNet(config) {\n    return __awaiter(this, void 0, void 0, function () {\n        var outputStride, quantBytes, multiplier, url, graphModel, mobilenet;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    outputStride = config.outputStride;\n                    quantBytes = config.quantBytes;\n                    multiplier = config.multiplier;\n                    if (tf == null) {\n                        throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please \" +\n                            \"also include @tensorflow/tfjs on the page before using this\\n        model.\");\n                    }\n                    url = saved_models_1.mobileNetSavedModel(outputStride, multiplier, quantBytes);\n                    return [4, tfconv.loadGraphModel(config.modelUrl || url)];\n                case 1:\n                    graphModel = _a.sent();\n                    mobilenet = new mobilenet_1.MobileNet(graphModel, outputStride);\n                    return [2, new BodyPix(mobilenet)];\n            }\n        });\n    });\n}\nfunction loadResNet(config) {\n    return __awaiter(this, void 0, void 0, function () {\n        var outputStride, quantBytes, url, graphModel, resnet;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    outputStride = config.outputStride;\n                    quantBytes = config.quantBytes;\n                    if (tf == null) {\n                        throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please \" +\n                            \"also include @tensorflow/tfjs on the page before using this\\n        model.\");\n                    }\n                    url = saved_models_1.resNet50SavedModel(outputStride, quantBytes);\n                    return [4, tfconv.loadGraphModel(config.modelUrl || url)];\n                case 1:\n                    graphModel = _a.sent();\n                    resnet = new resnet_1.ResNet(graphModel, outputStride);\n                    return [2, new BodyPix(resnet)];\n            }\n        });\n    });\n}\nfunction load(config) {\n    if (config === void 0) { config = MOBILENET_V1_CONFIG; }\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            config = validateModelConfig(config);\n            if (config.architecture === 'ResNet50') {\n                return [2, loadResNet(config)];\n            }\n            else if (config.architecture === 'MobileNetV1') {\n                return [2, loadMobileNet(config)];\n            }\n            else {\n                return [2, null];\n            }\n            return [2];\n        });\n    });\n}\nexports.load = load;\n//# sourceMappingURL=body_pix_model.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nfunction toFlattenedOneHotPartMap(partHeatmapScores) {\n    var numParts = partHeatmapScores.shape[2];\n    var partMapLocations = partHeatmapScores.argMax(2);\n    var partMapFlattened = partMapLocations.reshape([-1]);\n    return tf.oneHot(partMapFlattened, numParts);\n}\nfunction clipByMask2d(image, mask) {\n    return image.mul(mask);\n}\nfunction toMaskTensor(segmentScores, threshold) {\n    return tf.tidy(function () {\n        return segmentScores.greater(tf.scalar(threshold)).toInt();\n    });\n}\nexports.toMaskTensor = toMaskTensor;\nfunction decodePartSegmentation(segmentationMask, partHeatmapScores) {\n    var _a = partHeatmapScores.shape, partMapHeight = _a[0], partMapWidth = _a[1], numParts = _a[2];\n    return tf.tidy(function () {\n        var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n        var partNumbers = tf.range(0, numParts, 1, 'int32').expandDims(1);\n        var partMapFlattened = flattenedMap.matMul(partNumbers).toInt();\n        var partMap = partMapFlattened.reshape([partMapHeight, partMapWidth]);\n        var partMapShiftedUpForClipping = partMap.add(tf.scalar(1, 'int32'));\n        return clipByMask2d(partMapShiftedUpForClipping, segmentationMask)\n            .sub(tf.scalar(1, 'int32'));\n    });\n}\nexports.decodePartSegmentation = decodePartSegmentation;\nfunction decodeOnlyPartSegmentation(partHeatmapScores) {\n    var _a = partHeatmapScores.shape, partMapHeight = _a[0], partMapWidth = _a[1], numParts = _a[2];\n    return tf.tidy(function () {\n        var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n        var partNumbers = tf.range(0, numParts, 1, 'int32').expandDims(1);\n        var partMapFlattened = flattenedMap.matMul(partNumbers).toInt();\n        return partMapFlattened.reshape([partMapHeight, partMapWidth]);\n    });\n}\nexports.decodeOnlyPartSegmentation = decodeOnlyPartSegmentation;\n//# sourceMappingURL=decode_part_map.js.map","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar base_model_1 = require(\"./base_model\");\nvar MobileNet = (function (_super) {\n    __extends(MobileNet, _super);\n    function MobileNet() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    MobileNet.prototype.preprocessInput = function (input) {\n        return tf.tidy(function () { return tf.div(input, 127.5).sub(1.0); });\n    };\n    MobileNet.prototype.nameOutputResults = function (results) {\n        var offsets = results[0], segmentation = results[1], partHeatmaps = results[2], longOffsets = results[3], heatmap = results[4], displacementFwd = results[5], displacementBwd = results[6], partOffsets = results[7];\n        return {\n            offsets: offsets,\n            segmentation: segmentation,\n            partHeatmaps: partHeatmaps,\n            longOffsets: longOffsets,\n            heatmap: heatmap,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            partOffsets: partOffsets\n        };\n    };\n    return MobileNet;\n}(base_model_1.BaseModel));\nexports.MobileNet = MobileNet;\n//# sourceMappingURL=mobilenet.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar BaseModel = (function () {\n    function BaseModel(model, outputStride) {\n        this.model = model;\n        this.outputStride = outputStride;\n        var inputShape = this.model.inputs[0].shape;\n        tf.util.assert((inputShape[1] === -1) && (inputShape[2] === -1), function () { return \"Input shape [\" + inputShape[1] + \", \" + inputShape[2] + \"] \" +\n            \"must both be equal to or -1\"; });\n    }\n    BaseModel.prototype.predict = function (input) {\n        var _this = this;\n        return tf.tidy(function () {\n            var asFloat = _this.preprocessInput(input.toFloat());\n            var asBatch = asFloat.expandDims(0);\n            var results = _this.model.predict(asBatch);\n            var results3d = results.map(function (y) { return y.squeeze([0]); });\n            var namedResults = _this.nameOutputResults(results3d);\n            return {\n                heatmapScores: namedResults.heatmap.sigmoid(),\n                offsets: namedResults.offsets,\n                displacementFwd: namedResults.displacementFwd,\n                displacementBwd: namedResults.displacementBwd,\n                segmentation: namedResults.segmentation,\n                partHeatmaps: namedResults.partHeatmaps,\n                longOffsets: namedResults.longOffsets,\n                partOffsets: namedResults.partOffsets\n            };\n        });\n    };\n    BaseModel.prototype.dispose = function () {\n        this.model.dispose();\n    };\n    return BaseModel;\n}());\nexports.BaseModel = BaseModel;\n//# sourceMappingURL=base_model.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar decode_multiple_masks_cpu_1 = require(\"./decode_multiple_masks_cpu\");\nvar decode_multiple_masks_webgl_1 = require(\"./decode_multiple_masks_webgl\");\nfunction toPersonKSegmentation(segmentation, k) {\n    return tf.tidy(function () { return segmentation.equal(tf.scalar(k)).toInt(); });\n}\nexports.toPersonKSegmentation = toPersonKSegmentation;\nfunction toPersonKPartSegmentation(segmentation, bodyParts, k) {\n    return tf.tidy(function () { return segmentation.equal(tf.scalar(k))\n        .toInt()\n        .mul(bodyParts.add(1))\n        .sub(1); });\n}\nexports.toPersonKPartSegmentation = toPersonKPartSegmentation;\nfunction isWebGlBackend() {\n    return tfjs_core_1.getBackend() === 'webgl';\n}\nfunction decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, stride, _a, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (minPoseScore === void 0) { minPoseScore = 0.2; }\n    if (refineSteps === void 0) { refineSteps = 8; }\n    if (minKeypointScore === void 0) { minKeypointScore = 0.3; }\n    if (maxNumPeople === void 0) { maxNumPeople = 10; }\n    return __awaiter(this, void 0, void 0, function () {\n        var posesAboveScore, personSegmentationsData, personSegmentations, segmentationsData, longOffsetsData;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    posesAboveScore = poses.filter(function (pose) { return pose.score >= minPoseScore; });\n                    if (!isWebGlBackend()) return [3, 2];\n                    personSegmentations = tf.tidy(function () {\n                        var masksTensor = decode_multiple_masks_webgl_1.decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);\n                        return posesAboveScore.map(function (_, k) { return toPersonKSegmentation(masksTensor, k); });\n                    });\n                    return [4, Promise.all(personSegmentations.map(function (mask) { return mask.data(); }))];\n                case 1:\n                    personSegmentationsData =\n                        (_b.sent());\n                    personSegmentations.forEach(function (x) { return x.dispose(); });\n                    return [3, 5];\n                case 2: return [4, segmentation.data()];\n                case 3:\n                    segmentationsData = _b.sent();\n                    return [4, longOffsets.data()];\n                case 4:\n                    longOffsetsData = _b.sent();\n                    personSegmentationsData = decode_multiple_masks_cpu_1.decodeMultipleMasksCPU(segmentationsData, longOffsetsData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);\n                    _b.label = 5;\n                case 5: return [2, personSegmentationsData.map(function (data, i) { return ({ data: data, pose: posesAboveScore[i], width: width, height: height }); })];\n            }\n        });\n    });\n}\nexports.decodePersonInstanceMasks = decodePersonInstanceMasks;\nfunction decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, stride, _a, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (minPoseScore === void 0) { minPoseScore = 0.2; }\n    if (refineSteps === void 0) { refineSteps = 8; }\n    if (minKeypointScore === void 0) { minKeypointScore = 0.3; }\n    if (maxNumPeople === void 0) { maxNumPeople = 10; }\n    return __awaiter(this, void 0, void 0, function () {\n        var posesAboveScore, partSegmentationsByPersonData, partSegmentations, segmentationsData, longOffsetsData, partSegmentaionData;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    posesAboveScore = poses.filter(function (pose) { return pose.score >= minPoseScore; });\n                    if (!isWebGlBackend()) return [3, 2];\n                    partSegmentations = tf.tidy(function () {\n                        var masksTensor = decode_multiple_masks_webgl_1.decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);\n                        return posesAboveScore.map(function (_, k) {\n                            return toPersonKPartSegmentation(masksTensor, partSegmentation, k);\n                        });\n                    });\n                    return [4, Promise.all(partSegmentations.map(function (x) { return x.data(); }))];\n                case 1:\n                    partSegmentationsByPersonData =\n                        (_b.sent());\n                    partSegmentations.forEach(function (x) { return x.dispose(); });\n                    return [3, 6];\n                case 2: return [4, segmentation.data()];\n                case 3:\n                    segmentationsData = _b.sent();\n                    return [4, longOffsets.data()];\n                case 4:\n                    longOffsetsData = _b.sent();\n                    return [4, partSegmentation.data()];\n                case 5:\n                    partSegmentaionData = _b.sent();\n                    partSegmentationsByPersonData = decode_multiple_masks_cpu_1.decodeMultiplePartMasksCPU(segmentationsData, longOffsetsData, partSegmentaionData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);\n                    _b.label = 6;\n                case 6: return [2, partSegmentationsByPersonData.map(function (data, k) { return ({ pose: posesAboveScore[k], data: data, height: height, width: width }); })];\n            }\n        });\n    });\n}\nexports.decodePersonInstancePartMasks = decodePersonInstancePartMasks;\n//# sourceMappingURL=decode_instance_masks.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keypoints_1 = require(\"../keypoints\");\nvar util_1 = require(\"./util\");\nfunction computeDistance(embedding, pose, minPartScore) {\n    if (minPartScore === void 0) { minPartScore = 0.3; }\n    var distance = 0.0;\n    var numKpt = 0;\n    for (var p = 0; p < embedding.length; p++) {\n        if (pose.keypoints[p].score > minPartScore) {\n            numKpt += 1;\n            distance += Math.pow((embedding[p].x - pose.keypoints[p].position.x), 2) +\n                Math.pow((embedding[p].y - pose.keypoints[p].position.y), 2);\n        }\n    }\n    if (numKpt === 0) {\n        distance = Infinity;\n    }\n    else {\n        distance = distance / numKpt;\n    }\n    return distance;\n}\nfunction convertToPositionInOuput(position, _a, _b, stride) {\n    var padT = _a[0], padL = _a[1];\n    var scaleX = _b[0], scaleY = _b[1];\n    var y = Math.round(((padT + position.y + 1.0) * scaleY - 1.0) / stride);\n    var x = Math.round(((padL + position.x + 1.0) * scaleX - 1.0) / stride);\n    return { x: x, y: y };\n}\nfunction getEmbedding(location, keypointIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, _a) {\n    var height = _a[0], width = _a[1];\n    var newLocation = convertToPosition(location);\n    var nn = newLocation.y * outputResolutionX + newLocation.x;\n    var dy = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn) + keypointIndex];\n    var dx = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];\n    var y = location.y + dy;\n    var x = location.x + dx;\n    for (var t = 0; t < refineSteps; t++) {\n        y = Math.min(y, height - 1);\n        x = Math.min(x, width - 1);\n        var newPos = convertToPosition({ x: x, y: y });\n        var nn_1 = newPos.y * outputResolutionX + newPos.x;\n        dy = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn_1) + keypointIndex];\n        dx = longOffsets[keypoints_1.NUM_KEYPOINTS * (2 * nn_1 + 1) + keypointIndex];\n        y = y + dy;\n        x = x + dx;\n    }\n    return { x: x, y: y };\n}\nfunction matchEmbeddingToInstance(location, longOffsets, poses, numKptForMatching, _a, _b, outputResolutionX, _c, stride, refineSteps) {\n    var padT = _a[0], padL = _a[1];\n    var scaleX = _b[0], scaleY = _b[1];\n    var height = _c[0], width = _c[1];\n    var embed = [];\n    var convertToPosition = function (pair) {\n        return convertToPositionInOuput(pair, [padT, padL], [scaleX, scaleY], stride);\n    };\n    for (var keypointsIndex = 0; keypointsIndex < numKptForMatching; keypointsIndex++) {\n        var embedding = getEmbedding(location, keypointsIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, [height, width]);\n        embed.push(embedding);\n    }\n    var kMin = -1;\n    var kMinDist = Infinity;\n    for (var k = 0; k < poses.length; k++) {\n        var dist = computeDistance(embed, poses[k]);\n        if (dist < kMinDist) {\n            kMin = k;\n            kMinDist = dist;\n        }\n    }\n    return kMin;\n}\nfunction getOutputResolution(_a, stride) {\n    var inputResolutionY = _a[0], inputResolutionX = _a[1];\n    var outputResolutionX = Math.round((inputResolutionX - 1.0) / stride + 1.0);\n    var outputResolutionY = Math.round((inputResolutionY - 1.0) / stride + 1.0);\n    return [outputResolutionX, outputResolutionY];\n}\nfunction decodeMultipleMasksCPU(segmentation, longOffsets, posesAboveScore, height, width, stride, _a, padding, refineSteps, numKptForMatching) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (numKptForMatching === void 0) { numKptForMatching = 5; }\n    var dataArrays = posesAboveScore.map(function (x) { return new Uint8Array(height * width).fill(0); });\n    var padT = padding.top, padL = padding.left;\n    var _b = util_1.getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];\n    var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];\n    for (var i = 0; i < height; i += 1) {\n        for (var j = 0; j < width; j += 1) {\n            var n = i * width + j;\n            var prob = segmentation[n];\n            if (prob === 1) {\n                var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);\n                if (kMin >= 0) {\n                    dataArrays[kMin][n] = 1;\n                }\n            }\n        }\n    }\n    return dataArrays;\n}\nexports.decodeMultipleMasksCPU = decodeMultipleMasksCPU;\nfunction decodeMultiplePartMasksCPU(segmentation, longOffsets, partSegmentaion, posesAboveScore, height, width, stride, _a, padding, refineSteps, numKptForMatching) {\n    var inHeight = _a[0], inWidth = _a[1];\n    if (numKptForMatching === void 0) { numKptForMatching = 5; }\n    var dataArrays = posesAboveScore.map(function (x) { return new Int32Array(height * width).fill(-1); });\n    var padT = padding.top, padL = padding.left;\n    var _b = util_1.getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];\n    var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];\n    for (var i = 0; i < height; i += 1) {\n        for (var j = 0; j < width; j += 1) {\n            var n = i * width + j;\n            var prob = segmentation[n];\n            if (prob === 1) {\n                var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);\n                if (kMin >= 0) {\n                    dataArrays[kMin][n] = partSegmentaion[n];\n                }\n            }\n        }\n    }\n    return dataArrays;\n}\nexports.decodeMultiplePartMasksCPU = decodeMultiplePartMasksCPU;\n//# sourceMappingURL=decode_multiple_masks_cpu.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PART_NAMES = [\n    'nose', 'leftEye', 'rightEye', 'leftEar', 'rightEar', 'leftShoulder',\n    'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist',\n    'leftHip', 'rightHip', 'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'\n];\nexports.NUM_KEYPOINTS = exports.PART_NAMES.length;\nexports.PART_IDS = exports.PART_NAMES.reduce(function (result, jointName, i) {\n    result[jointName] = i;\n    return result;\n}, {});\nvar CONNECTED_PART_NAMES = [\n    ['leftHip', 'leftShoulder'], ['leftElbow', 'leftShoulder'],\n    ['leftElbow', 'leftWrist'], ['leftHip', 'leftKnee'],\n    ['leftKnee', 'leftAnkle'], ['rightHip', 'rightShoulder'],\n    ['rightElbow', 'rightShoulder'], ['rightElbow', 'rightWrist'],\n    ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'],\n    ['leftShoulder', 'rightShoulder'], ['leftHip', 'rightHip']\n];\nexports.POSE_CHAIN = [\n    ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n    ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n    ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n    ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n    ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n    ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n    ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n    ['rightKnee', 'rightAnkle']\n];\nexports.CONNECTED_PART_INDICES = CONNECTED_PART_NAMES.map(function (_a) {\n    var jointNameA = _a[0], jointNameB = _a[1];\n    return ([exports.PART_IDS[jointNameA], exports.PART_IDS[jointNameB]]);\n});\n//# sourceMappingURL=keypoints.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keypoints_1 = require(\"../keypoints\");\nfunction getScale(_a, _b, padding) {\n    var height = _a[0], width = _a[1];\n    var inputResolutionY = _b[0], inputResolutionX = _b[1];\n    var padT = padding.top, padB = padding.bottom, padL = padding.left, padR = padding.right;\n    var scaleY = inputResolutionY / (padT + padB + height);\n    var scaleX = inputResolutionX / (padL + padR + width);\n    return [scaleX, scaleY];\n}\nexports.getScale = getScale;\nfunction getOffsetPoint(y, x, keypoint, offsets) {\n    return {\n        y: offsets.get(y, x, keypoint),\n        x: offsets.get(y, x, keypoint + keypoints_1.NUM_KEYPOINTS)\n    };\n}\nexports.getOffsetPoint = getOffsetPoint;\nfunction getImageCoords(part, outputStride, offsets) {\n    var heatmapY = part.heatmapY, heatmapX = part.heatmapX, keypoint = part.id;\n    var _a = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets), y = _a.y, x = _a.x;\n    return {\n        x: part.heatmapX * outputStride + x,\n        y: part.heatmapY * outputStride + y\n    };\n}\nexports.getImageCoords = getImageCoords;\nfunction fillArray(element, size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = element;\n    }\n    return result;\n}\nexports.fillArray = fillArray;\nfunction clamp(a, min, max) {\n    if (a < min) {\n        return min;\n    }\n    if (a > max) {\n        return max;\n    }\n    return a;\n}\nexports.clamp = clamp;\nfunction squaredDistance(y1, x1, y2, x2) {\n    var dy = y2 - y1;\n    var dx = x2 - x1;\n    return dy * dy + dx * dx;\n}\nexports.squaredDistance = squaredDistance;\nfunction addVectors(a, b) {\n    return { x: a.x + b.x, y: a.y + b.y };\n}\nexports.addVectors = addVectors;\nfunction clampVector(a, min, max) {\n    return { y: clamp(a.y, min, max), x: clamp(a.x, min, max) };\n}\nexports.clampVector = clampVector;\n//# sourceMappingURL=util.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nvar keypoints_1 = require(\"../keypoints\");\nvar util_1 = require(\"./util\");\nfunction decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, _a, padding, refineSteps, minKptScore, maxNumPeople) {\n    var inHeight = _a[0], inWidth = _a[1];\n    var _b = segmentation.shape, origHeight = _b[0], origWidth = _b[1];\n    var _c = longOffsets.shape.slice(0, 2), outHeight = _c[0], outWidth = _c[1];\n    var shapedLongOffsets = longOffsets.reshape([outHeight, outWidth, 2, keypoints_1.NUM_KEYPOINTS]);\n    var poseVals = new Float32Array(maxNumPeople * keypoints_1.NUM_KEYPOINTS * 3).fill(0.0);\n    for (var i = 0; i < posesAboveScore.length; i++) {\n        var poseOffset = i * keypoints_1.NUM_KEYPOINTS * 3;\n        var pose = posesAboveScore[i];\n        for (var kp = 0; kp < keypoints_1.NUM_KEYPOINTS; kp++) {\n            var keypoint = pose.keypoints[kp];\n            var offset = poseOffset + kp * 3;\n            poseVals[offset] = keypoint.score;\n            poseVals[offset + 1] = keypoint.position.y;\n            poseVals[offset + 2] = keypoint.position.x;\n        }\n    }\n    var _d = util_1.getScale([height, width], [inHeight, inWidth], padding), scaleX = _d[0], scaleY = _d[1];\n    var posesTensor = tf.tensor(poseVals, [maxNumPeople, keypoints_1.NUM_KEYPOINTS, 3]);\n    var padT = padding.top, padL = padding.left;\n    var program = {\n        variableNames: ['segmentation', 'longOffsets', 'poses'],\n        outputShape: [origHeight, origWidth],\n        userCode: \"\\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\\n    }\\n\\n    float convertToPositionInOutputFloat(\\n        int pos, int pad, float scale, int stride) {\\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\\n    }\\n\\n    float dist(float x1, float y1, float x2, float y2) {\\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\\n    }\\n\\n    float sampleLongOffsets(float h, float w, int d, int k) {\\n      float fh = fract(h);\\n      float fw = fract(w);\\n      int clH = int(ceil(h));\\n      int clW = int(ceil(w));\\n      int flH = int(floor(h));\\n      int flW = int(floor(w));\\n      float o11 = getLongOffsets(flH, flW, d, k);\\n      float o12 = getLongOffsets(flH, clW, d, k);\\n      float o21 = getLongOffsets(clH, flW, d, k);\\n      float o22 = getLongOffsets(clH, clW, d, k);\\n      float o1 = mix(o11, o12, fw);\\n      float o2 = mix(o21, o22, fw);\\n      return mix(o1, o2, fh);\\n    }\\n\\n    int findNearestPose(int h, int w) {\\n      float prob = getSegmentation(h, w);\\n      if (prob < 1.0) {\\n        return -1;\\n      }\\n\\n      // Done(Tyler): convert from output space h/w to strided space.\\n      float stridedH = convertToPositionInOutputFloat(\\n        h, \" + padT + \", \" + scaleY + \", \" + stride + \");\\n      float stridedW = convertToPositionInOutputFloat(\\n        w, \" + padL + \", \" + scaleX + \", \" + stride + \");\\n\\n      float minDist = 1000000.0;\\n      int iMin = -1;\\n      for (int i = 0; i < \" + maxNumPeople + \"; i++) {\\n        float curDistSum = 0.0;\\n        int numKpt = 0;\\n        for (int k = 0; k < \" + keypoints_1.NUM_KEYPOINTS + \"; k++) {\\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\\n\\n          float y = float(h) + dy;\\n          float x = float(w) + dx;\\n\\n          for (int s = 0; s < \" + refineSteps + \"; s++) {\\n            int yRounded = round(min(y, float(\" + (height - 1.0) + \")));\\n            int xRounded = round(min(x, float(\" + (width - 1.0) + \")));\\n\\n            float yStrided = convertToPositionInOutputFloat(\\n              yRounded, \" + padT + \", \" + scaleY + \", \" + stride + \");\\n            float xStrided = convertToPositionInOutputFloat(\\n              xRounded, \" + padL + \", \" + scaleX + \", \" + stride + \");\\n\\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\\n\\n            y = y + dy;\\n            x = x + dx;\\n          }\\n\\n          float poseScore = getPoses(i, k, 0);\\n          float poseY = getPoses(i, k, 1);\\n          float poseX = getPoses(i, k, 2);\\n          if (poseScore > \" + minKptScore + \") {\\n            numKpt = numKpt + 1;\\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\\n          }\\n        }\\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\\n          minDist = curDistSum / float(numKpt);\\n          iMin = i;\\n        }\\n      }\\n      return iMin;\\n    }\\n\\n    void main() {\\n        ivec2 coords = getOutputCoords();\\n        int nearestPose = findNearestPose(coords[0], coords[1]);\\n        setOutput(float(nearestPose));\\n      }\\n  \"\n    };\n    var webglBackend = tf.backend();\n    return webglBackend.compileAndRun(program, [segmentation, shapedLongOffsets, posesTensor]);\n}\nexports.decodeMultipleMasksWebGl = decodeMultipleMasksWebGl;\n//# sourceMappingURL=decode_multiple_masks_webgl.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar build_part_with_score_queue_1 = require(\"./build_part_with_score_queue\");\nvar decode_pose_1 = require(\"./decode_pose\");\nvar util_1 = require(\"./util\");\nfunction withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, _a, keypointId) {\n    var x = _a.x, y = _a.y;\n    return poses.some(function (_a) {\n        var keypoints = _a.keypoints;\n        var correspondingKeypoint = keypoints[keypointId].position;\n        return util_1.squaredDistance(y, x, correspondingKeypoint.y, correspondingKeypoint.x) <=\n            squaredNmsRadius;\n    });\n}\nfunction getInstanceScore(existingPoses, squaredNmsRadius, instanceKeypoints) {\n    var notOverlappedKeypointScores = instanceKeypoints.reduce(function (result, _a, keypointId) {\n        var position = _a.position, score = _a.score;\n        if (!withinNmsRadiusOfCorrespondingPoint(existingPoses, squaredNmsRadius, position, keypointId)) {\n            result += score;\n        }\n        return result;\n    }, 0.0);\n    return notOverlappedKeypointScores /= instanceKeypoints.length;\n}\nvar kLocalMaximumRadius = 1;\nfunction decodeMultiplePoses(scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, outputStride, maxPoseDetections, scoreThreshold, nmsRadius) {\n    if (scoreThreshold === void 0) { scoreThreshold = 0.5; }\n    if (nmsRadius === void 0) { nmsRadius = 20; }\n    var poses = [];\n    var queue = build_part_with_score_queue_1.buildPartWithScoreQueue(scoreThreshold, kLocalMaximumRadius, scoresBuffer);\n    var squaredNmsRadius = nmsRadius * nmsRadius;\n    while (poses.length < maxPoseDetections && !queue.empty()) {\n        var root = queue.dequeue();\n        var rootImageCoords = util_1.getImageCoords(root.part, outputStride, offsetsBuffer);\n        if (withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, rootImageCoords, root.part.id)) {\n            continue;\n        }\n        var keypoints = decode_pose_1.decodePose(root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer, displacementsBwdBuffer);\n        var score = getInstanceScore(poses, squaredNmsRadius, keypoints);\n        poses.push({ keypoints: keypoints, score: score });\n    }\n    return poses;\n}\nexports.decodeMultiplePoses = decodeMultiplePoses;\n//# sourceMappingURL=decode_multiple_poses.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar max_heap_1 = require(\"./max_heap\");\nfunction scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores) {\n    var _a = scores.shape, height = _a[0], width = _a[1];\n    var localMaximum = true;\n    var yStart = Math.max(heatmapY - localMaximumRadius, 0);\n    var yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);\n    for (var yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {\n        var xStart = Math.max(heatmapX - localMaximumRadius, 0);\n        var xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);\n        for (var xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {\n            if (scores.get(yCurrent, xCurrent, keypointId) > score) {\n                localMaximum = false;\n                break;\n            }\n        }\n        if (!localMaximum) {\n            break;\n        }\n    }\n    return localMaximum;\n}\nfunction buildPartWithScoreQueue(scoreThreshold, localMaximumRadius, scores) {\n    var _a = scores.shape, height = _a[0], width = _a[1], numKeypoints = _a[2];\n    var queue = new max_heap_1.MaxHeap(height * width * numKeypoints, function (_a) {\n        var score = _a.score;\n        return score;\n    });\n    for (var heatmapY = 0; heatmapY < height; ++heatmapY) {\n        for (var heatmapX = 0; heatmapX < width; ++heatmapX) {\n            for (var keypointId = 0; keypointId < numKeypoints; ++keypointId) {\n                var score = scores.get(heatmapY, heatmapX, keypointId);\n                if (score < scoreThreshold) {\n                    continue;\n                }\n                if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores)) {\n                    queue.enqueue({ score: score, part: { heatmapY: heatmapY, heatmapX: heatmapX, id: keypointId } });\n                }\n            }\n        }\n    }\n    return queue;\n}\nexports.buildPartWithScoreQueue = buildPartWithScoreQueue;\n//# sourceMappingURL=build_part_with_score_queue.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction half(k) {\n    return Math.floor(k / 2);\n}\nvar MaxHeap = (function () {\n    function MaxHeap(maxSize, getElementValue) {\n        this.priorityQueue = new Array(maxSize);\n        this.numberOfElements = -1;\n        this.getElementValue = getElementValue;\n    }\n    MaxHeap.prototype.enqueue = function (x) {\n        this.priorityQueue[++this.numberOfElements] = x;\n        this.swim(this.numberOfElements);\n    };\n    MaxHeap.prototype.dequeue = function () {\n        var max = this.priorityQueue[0];\n        this.exchange(0, this.numberOfElements--);\n        this.sink(0);\n        this.priorityQueue[this.numberOfElements + 1] = null;\n        return max;\n    };\n    MaxHeap.prototype.empty = function () {\n        return this.numberOfElements === -1;\n    };\n    MaxHeap.prototype.size = function () {\n        return this.numberOfElements + 1;\n    };\n    MaxHeap.prototype.all = function () {\n        return this.priorityQueue.slice(0, this.numberOfElements + 1);\n    };\n    MaxHeap.prototype.max = function () {\n        return this.priorityQueue[0];\n    };\n    MaxHeap.prototype.swim = function (k) {\n        while (k > 0 && this.less(half(k), k)) {\n            this.exchange(k, half(k));\n            k = half(k);\n        }\n    };\n    MaxHeap.prototype.sink = function (k) {\n        while (2 * k <= this.numberOfElements) {\n            var j = 2 * k;\n            if (j < this.numberOfElements && this.less(j, j + 1)) {\n                j++;\n            }\n            if (!this.less(k, j)) {\n                break;\n            }\n            this.exchange(k, j);\n            k = j;\n        }\n    };\n    MaxHeap.prototype.getValueAt = function (i) {\n        return this.getElementValue(this.priorityQueue[i]);\n    };\n    MaxHeap.prototype.less = function (i, j) {\n        return this.getValueAt(i) < this.getValueAt(j);\n    };\n    MaxHeap.prototype.exchange = function (i, j) {\n        var t = this.priorityQueue[i];\n        this.priorityQueue[i] = this.priorityQueue[j];\n        this.priorityQueue[j] = t;\n    };\n    return MaxHeap;\n}());\nexports.MaxHeap = MaxHeap;\n//# sourceMappingURL=max_heap.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar keypoints_1 = require(\"../keypoints\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"./util\");\nvar parentChildrenTuples = keypoints_1.POSE_CHAIN.map(function (_a) {\n    var parentJoinName = _a[0], childJoinName = _a[1];\n    return ([keypoints_1.PART_IDS[parentJoinName], keypoints_1.PART_IDS[childJoinName]]);\n});\nvar parentToChildEdges = parentChildrenTuples.map(function (_a) {\n    var childJointId = _a[1];\n    return childJointId;\n});\nvar childToParentEdges = parentChildrenTuples.map(function (_a) {\n    var parentJointId = _a[0];\n    return parentJointId;\n});\nfunction getDisplacement(edgeId, point, displacements) {\n    var numEdges = displacements.shape[2] / 2;\n    return {\n        y: displacements.get(point.y, point.x, edgeId),\n        x: displacements.get(point.y, point.x, numEdges + edgeId)\n    };\n}\nfunction getStridedIndexNearPoint(point, outputStride, height, width) {\n    return {\n        y: util_1.clamp(Math.round(point.y / outputStride), 0, height - 1),\n        x: util_1.clamp(Math.round(point.x / outputStride), 0, width - 1)\n    };\n}\nfunction traverseToTargetKeypoint(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements, offsetRefineStep) {\n    if (offsetRefineStep === void 0) { offsetRefineStep = 2; }\n    var _a = scoresBuffer.shape, height = _a[0], width = _a[1];\n    var sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, outputStride, height, width);\n    var displacement = getDisplacement(edgeId, sourceKeypointIndices, displacements);\n    var displacedPoint = util_2.addVectors(sourceKeypoint.position, displacement);\n    var targetKeypoint = displacedPoint;\n    for (var i = 0; i < offsetRefineStep; i++) {\n        var targetKeypointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n        var offsetPoint = util_1.getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId, offsets);\n        targetKeypoint = util_2.addVectors({\n            x: targetKeypointIndices.x * outputStride,\n            y: targetKeypointIndices.y * outputStride\n        }, { x: offsetPoint.x, y: offsetPoint.y });\n    }\n    var targetKeyPointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n    var score = scoresBuffer.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);\n    return { position: targetKeypoint, part: keypoints_1.PART_NAMES[targetKeypointId], score: score };\n}\nfunction decodePose(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {\n    var numParts = scores.shape[2];\n    var numEdges = parentToChildEdges.length;\n    var instanceKeypoints = new Array(numParts);\n    var rootPart = root.part, rootScore = root.score;\n    var rootPoint = util_2.getImageCoords(rootPart, outputStride, offsets);\n    instanceKeypoints[rootPart.id] = {\n        score: rootScore,\n        part: keypoints_1.PART_NAMES[rootPart.id],\n        position: rootPoint\n    };\n    for (var edge = numEdges - 1; edge >= 0; --edge) {\n        var sourceKeypointId = parentToChildEdges[edge];\n        var targetKeypointId = childToParentEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);\n        }\n    }\n    for (var edge = 0; edge < numEdges; ++edge) {\n        var sourceKeypointId = childToParentEdges[edge];\n        var targetKeypointId = parentToChildEdges[edge];\n        if (instanceKeypoints[sourceKeypointId] &&\n            !instanceKeypoints[targetKeypointId]) {\n            instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);\n        }\n    }\n    return instanceKeypoints;\n}\nexports.decodePose = decodePose;\n//# sourceMappingURL=decode_pose.js.map","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar base_model_1 = require(\"./base_model\");\nvar imageNetMean = [-123.15, -115.90, -103.06];\nvar ResNet = (function (_super) {\n    __extends(ResNet, _super);\n    function ResNet() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResNet.prototype.preprocessInput = function (input) {\n        return input.add(imageNetMean);\n    };\n    ResNet.prototype.nameOutputResults = function (results) {\n        var displacementBwd = results[0], displacementFwd = results[1], heatmap = results[2], longOffsets = results[3], offsets = results[4], partHeatmaps = results[5], segmentation = results[6], partOffsets = results[7];\n        return {\n            offsets: offsets,\n            segmentation: segmentation,\n            partHeatmaps: partHeatmaps,\n            longOffsets: longOffsets,\n            heatmap: heatmap,\n            displacementFwd: displacementFwd,\n            displacementBwd: displacementBwd,\n            partOffsets: partOffsets\n        };\n    };\n    return ResNet;\n}(base_model_1.BaseModel));\nexports.ResNet = ResNet;\n//# sourceMappingURL=resnet.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar RESNET50_BASE_URL = 'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/';\nvar MOBILENET_BASE_URL = 'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/';\nfunction resNet50SavedModel(stride, quantBytes) {\n    var graphJson = \"model-stride\" + stride + \".json\";\n    if (quantBytes === 4) {\n        return RESNET50_BASE_URL + \"float/\" + graphJson;\n    }\n    else {\n        return RESNET50_BASE_URL + (\"quant\" + quantBytes + \"/\") + graphJson;\n    }\n}\nexports.resNet50SavedModel = resNet50SavedModel;\nfunction mobileNetSavedModel(stride, multiplier, quantBytes) {\n    var toStr = { 1.0: '100', 0.75: '075', 0.50: '050' };\n    var graphJson = \"model-stride\" + stride + \".json\";\n    if (quantBytes === 4) {\n        return MOBILENET_BASE_URL + (\"float/\" + toStr[multiplier] + \"/\") + graphJson;\n    }\n    else {\n        return MOBILENET_BASE_URL + (\"quant\" + quantBytes + \"/\" + toStr[multiplier] + \"/\") +\n            graphJson;\n    }\n}\nexports.mobileNetSavedModel = mobileNetSavedModel;\n//# sourceMappingURL=saved_models.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs-core\");\nfunction getSizeFromImageLikeElement(input) {\n    if (input.offsetHeight !== 0 && input.offsetWidth !== 0) {\n        return [input.offsetHeight, input.offsetWidth];\n    }\n    else if (input.height != null && input.width != null) {\n        return [input.height, input.width];\n    }\n    else {\n        throw new Error(\"HTMLImageElement must have height and width attributes set.\");\n    }\n}\nfunction getSizeFromVideoElement(input) {\n    if (input.height != null && input.width != null) {\n        return [input.height, input.width];\n    }\n    else {\n        return [input.videoHeight, input.videoWidth];\n    }\n}\nfunction getInputSize(input) {\n    if ((typeof (HTMLCanvasElement) !== 'undefined' &&\n        input instanceof HTMLCanvasElement) ||\n        (typeof (HTMLImageElement) !== 'undefined' &&\n            input instanceof HTMLImageElement)) {\n        return getSizeFromImageLikeElement(input);\n    }\n    else if (typeof (ImageData) !== 'undefined' && input instanceof ImageData) {\n        return [input.height, input.width];\n    }\n    else if (typeof (HTMLVideoElement) !== 'undefined' &&\n        input instanceof HTMLVideoElement) {\n        return getSizeFromVideoElement(input);\n    }\n    else if (input instanceof tf.Tensor) {\n        return [input.shape[0], input.shape[1]];\n    }\n    else {\n        throw new Error(\"error: Unknown input type: \" + input + \".\");\n    }\n}\nexports.getInputSize = getInputSize;\nfunction isValidInputResolution(resolution, outputStride) {\n    return (resolution - 1) % outputStride === 0;\n}\nfunction toValidInputResolution(inputResolution, outputStride) {\n    if (isValidInputResolution(inputResolution, outputStride)) {\n        return inputResolution;\n    }\n    return Math.floor(inputResolution / outputStride) * outputStride + 1;\n}\nexports.toValidInputResolution = toValidInputResolution;\nvar INTERNAL_RESOLUTION_STRING_OPTIONS = {\n    low: 'low',\n    medium: 'medium',\n    high: 'high',\n    full: 'full'\n};\nvar INTERNAL_RESOLUTION_PERCENTAGES = (_a = {},\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.low] = 0.25,\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.medium] = 0.5,\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.high] = 0.75,\n    _a[INTERNAL_RESOLUTION_STRING_OPTIONS.full] = 1.0,\n    _a);\nvar MIN_INTERNAL_RESOLUTION = 0.1;\nvar MAX_INTERNAL_RESOLUTION = 2.0;\nfunction toInternalResolutionPercentage(internalResolution) {\n    if (typeof internalResolution === 'string') {\n        var result = INTERNAL_RESOLUTION_PERCENTAGES[internalResolution];\n        tf.util.assert(typeof result === 'number', function () { return \"string value of inputResolution must be one of \" + Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS)\n            .join(',') + \" but was \" + internalResolution + \".\"; });\n        return result;\n    }\n    else {\n        tf.util.assert(typeof internalResolution === 'number' &&\n            internalResolution <= MAX_INTERNAL_RESOLUTION &&\n            internalResolution >= MIN_INTERNAL_RESOLUTION, function () {\n            return \"inputResolution must be a string or number between \" + MIN_INTERNAL_RESOLUTION + \" and \" + MAX_INTERNAL_RESOLUTION + \", but \" +\n                (\"was \" + internalResolution);\n        });\n        return internalResolution;\n    }\n}\nfunction toInputResolutionHeightAndWidth(internalResolution, outputStride, _a) {\n    var inputHeight = _a[0], inputWidth = _a[1];\n    var internalResolutionPercentage = toInternalResolutionPercentage(internalResolution);\n    return [\n        toValidInputResolution(inputHeight * internalResolutionPercentage, outputStride),\n        toValidInputResolution(inputWidth * internalResolutionPercentage, outputStride)\n    ];\n}\nexports.toInputResolutionHeightAndWidth = toInputResolutionHeightAndWidth;\nfunction toInputTensor(input) {\n    return input instanceof tf.Tensor ? input : tf.browser.fromPixels(input);\n}\nexports.toInputTensor = toInputTensor;\nfunction resizeAndPadTo(imageTensor, _a, flipHorizontal) {\n    var targetH = _a[0], targetW = _a[1];\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var _b = imageTensor.shape, height = _b[0], width = _b[1];\n    var targetAspect = targetW / targetH;\n    var aspect = width / height;\n    var resizeW;\n    var resizeH;\n    var padL;\n    var padR;\n    var padT;\n    var padB;\n    if (aspect > targetAspect) {\n        resizeW = targetW;\n        resizeH = Math.ceil(resizeW / aspect);\n        var padHeight = targetH - resizeH;\n        padL = 0;\n        padR = 0;\n        padT = Math.floor(padHeight / 2);\n        padB = targetH - (resizeH + padT);\n    }\n    else {\n        resizeH = targetH;\n        resizeW = Math.ceil(targetH * aspect);\n        var padWidth = targetW - resizeW;\n        padL = Math.floor(padWidth / 2);\n        padR = targetW - (resizeW + padL);\n        padT = 0;\n        padB = 0;\n    }\n    var resizedAndPadded = tf.tidy(function () {\n        var resized;\n        if (flipHorizontal) {\n            resized = imageTensor.reverse(1).resizeBilinear([resizeH, resizeW]);\n        }\n        else {\n            resized = imageTensor.resizeBilinear([resizeH, resizeW]);\n        }\n        var padded = tf.pad3d(resized, [[padT, padB], [padL, padR], [0, 0]]);\n        return padded;\n    });\n    return { resizedAndPadded: resizedAndPadded, paddedBy: [[padT, padB], [padL, padR]] };\n}\nexports.resizeAndPadTo = resizeAndPadTo;\nfunction scaleAndCropToInputTensorShape(tensor, _a, _b, _c, applySigmoidActivation) {\n    var inputTensorHeight = _a[0], inputTensorWidth = _a[1];\n    var resizedAndPaddedHeight = _b[0], resizedAndPaddedWidth = _b[1];\n    var _d = _c[0], padT = _d[0], padB = _d[1], _e = _c[1], padL = _e[0], padR = _e[1];\n    if (applySigmoidActivation === void 0) { applySigmoidActivation = false; }\n    return tf.tidy(function () {\n        var inResizedAndPadded = tensor.resizeBilinear([resizedAndPaddedHeight, resizedAndPaddedWidth], true);\n        if (applySigmoidActivation) {\n            inResizedAndPadded = inResizedAndPadded.sigmoid();\n        }\n        return removePaddingAndResizeBack(inResizedAndPadded, [inputTensorHeight, inputTensorWidth], [[padT, padB], [padL, padR]]);\n    });\n}\nexports.scaleAndCropToInputTensorShape = scaleAndCropToInputTensorShape;\nfunction removePaddingAndResizeBack(resizedAndPadded, _a, _b) {\n    var originalHeight = _a[0], originalWidth = _a[1];\n    var _c = _b[0], padT = _c[0], padB = _c[1], _d = _b[1], padL = _d[0], padR = _d[1];\n    return tf.tidy(function () {\n        return tf.image\n            .cropAndResize(resizedAndPadded.expandDims(), [[\n                padT / (originalHeight + padT + padB - 1.0),\n                padL / (originalWidth + padL + padR - 1.0),\n                (padT + originalHeight - 1.0) /\n                    (originalHeight + padT + padB - 1.0),\n                (padL + originalWidth - 1.0) / (originalWidth + padL + padR - 1.0)\n            ]], [0], [originalHeight, originalWidth])\n            .squeeze([0]);\n    });\n}\nexports.removePaddingAndResizeBack = removePaddingAndResizeBack;\nfunction resize2d(tensor, resolution, nearestNeighbor) {\n    return tf.tidy(function () {\n        return tensor.expandDims(2)\n            .resizeBilinear(resolution, nearestNeighbor)\n            .squeeze();\n    });\n}\nexports.resize2d = resize2d;\nfunction padAndResizeTo(input, _a) {\n    var targetH = _a[0], targetW = _a[1];\n    var _b = getInputSize(input), height = _b[0], width = _b[1];\n    var targetAspect = targetW / targetH;\n    var aspect = width / height;\n    var _c = [0, 0, 0, 0], padT = _c[0], padB = _c[1], padL = _c[2], padR = _c[3];\n    if (aspect < targetAspect) {\n        padT = 0;\n        padB = 0;\n        padL = Math.round(0.5 * (targetAspect * height - width));\n        padR = Math.round(0.5 * (targetAspect * height - width));\n    }\n    else {\n        padT = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n        padB = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n        padL = 0;\n        padR = 0;\n    }\n    var resized = tf.tidy(function () {\n        var imageTensor = toInputTensor(input);\n        imageTensor = tf.pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);\n        return imageTensor.resizeBilinear([targetH, targetW]);\n    });\n    return { resized: resized, padding: { top: padT, left: padL, right: padR, bottom: padB } };\n}\nexports.padAndResizeTo = padAndResizeTo;\nfunction toTensorBuffers3D(tensors) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2, Promise.all(tensors.map(function (tensor) { return tensor.buffer(); }))];\n        });\n    });\n}\nexports.toTensorBuffers3D = toTensorBuffers3D;\nfunction scalePose(pose, scaleY, scaleX, offsetY, offsetX) {\n    if (offsetY === void 0) { offsetY = 0; }\n    if (offsetX === void 0) { offsetX = 0; }\n    return {\n        score: pose.score,\n        keypoints: pose.keypoints.map(function (_a) {\n            var score = _a.score, part = _a.part, position = _a.position;\n            return ({\n                score: score,\n                part: part,\n                position: {\n                    x: position.x * scaleX + offsetX,\n                    y: position.y * scaleY + offsetY\n                }\n            });\n        })\n    };\n}\nexports.scalePose = scalePose;\nfunction scalePoses(poses, scaleY, scaleX, offsetY, offsetX) {\n    if (offsetY === void 0) { offsetY = 0; }\n    if (offsetX === void 0) { offsetX = 0; }\n    if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {\n        return poses;\n    }\n    return poses.map(function (pose) { return scalePose(pose, scaleY, scaleX, offsetY, offsetX); });\n}\nexports.scalePoses = scalePoses;\nfunction flipPoseHorizontal(pose, imageWidth) {\n    return {\n        score: pose.score,\n        keypoints: pose.keypoints.map(function (_a) {\n            var score = _a.score, part = _a.part, position = _a.position;\n            return ({\n                score: score,\n                part: part,\n                position: { x: imageWidth - 1 - position.x, y: position.y }\n            });\n        })\n    };\n}\nexports.flipPoseHorizontal = flipPoseHorizontal;\nfunction flipPosesHorizontal(poses, imageWidth) {\n    if (imageWidth <= 0) {\n        return poses;\n    }\n    return poses.map(function (pose) { return flipPoseHorizontal(pose, imageWidth); });\n}\nexports.flipPosesHorizontal = flipPosesHorizontal;\nfunction scaleAndFlipPoses(poses, _a, _b, padding, flipHorizontal) {\n    var height = _a[0], width = _a[1];\n    var inputResolutionHeight = _b[0], inputResolutionWidth = _b[1];\n    var scaleY = (height + padding.top + padding.bottom) / (inputResolutionHeight);\n    var scaleX = (width + padding.left + padding.right) / (inputResolutionWidth);\n    var scaledPoses = scalePoses(poses, scaleY, scaleX, -padding.top, -padding.left);\n    if (flipHorizontal) {\n        return flipPosesHorizontal(scaledPoses, width);\n    }\n    else {\n        return scaledPoses;\n    }\n}\nexports.scaleAndFlipPoses = scaleAndFlipPoses;\n//# sourceMappingURL=util.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar blur_1 = require(\"./blur\");\nvar util_1 = require(\"./util\");\nvar offScreenCanvases = {};\nfunction isSafari() {\n    return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent));\n}\nfunction assertSameDimensions(_a, _b, nameA, nameB) {\n    var widthA = _a.width, heightA = _a.height;\n    var widthB = _b.width, heightB = _b.height;\n    if (widthA !== widthB || heightA !== heightB) {\n        throw new Error(\"error: dimensions must match. \" + nameA + \" has dimensions \" + widthA + \"x\" + heightA + \", \" + nameB + \" has dimensions \" + widthB + \"x\" + heightB);\n    }\n}\nfunction flipCanvasHorizontal(canvas) {\n    var ctx = canvas.getContext('2d');\n    ctx.scale(-1, 1);\n    ctx.translate(-canvas.width, 0);\n}\nfunction drawWithCompositing(ctx, image, compositOperation) {\n    ctx.globalCompositeOperation = compositOperation;\n    ctx.drawImage(image, 0, 0);\n}\nfunction createOffScreenCanvas() {\n    var offScreenCanvas = document.createElement('canvas');\n    return offScreenCanvas;\n}\nfunction ensureOffscreenCanvasCreated(id) {\n    if (!offScreenCanvases[id]) {\n        offScreenCanvases[id] = createOffScreenCanvas();\n    }\n    return offScreenCanvases[id];\n}\nfunction drawAndBlurImageOnCanvas(image, blurAmount, canvas) {\n    var height = image.height, width = image.width;\n    var ctx = canvas.getContext('2d');\n    canvas.width = width;\n    canvas.height = height;\n    ctx.clearRect(0, 0, width, height);\n    ctx.save();\n    if (isSafari()) {\n        blur_1.cpuBlur(canvas, image, blurAmount);\n    }\n    else {\n        ctx.filter = \"blur(\" + blurAmount + \"px)\";\n        ctx.drawImage(image, 0, 0, width, height);\n    }\n    ctx.restore();\n}\nfunction drawAndBlurImageOnOffScreenCanvas(image, blurAmount, offscreenCanvasName) {\n    var canvas = ensureOffscreenCanvasCreated(offscreenCanvasName);\n    if (blurAmount === 0) {\n        renderImageToCanvas(image, canvas);\n    }\n    else {\n        drawAndBlurImageOnCanvas(image, blurAmount, canvas);\n    }\n    return canvas;\n}\nfunction renderImageToCanvas(image, canvas) {\n    var width = image.width, height = image.height;\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n    ctx.drawImage(image, 0, 0, width, height);\n}\nfunction renderImageDataToCanvas(image, canvas) {\n    canvas.width = image.width;\n    canvas.height = image.height;\n    var ctx = canvas.getContext('2d');\n    ctx.putImageData(image, 0, 0);\n}\nfunction renderImageDataToOffScreenCanvas(image, canvasName) {\n    var canvas = ensureOffscreenCanvasCreated(canvasName);\n    renderImageDataToCanvas(image, canvas);\n    return canvas;\n}\nfunction toMask(personOrPartSegmentation, foreground, background, drawContour, foregroundIds) {\n    if (foreground === void 0) { foreground = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n    }; }\n    if (background === void 0) { background = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    }; }\n    if (drawContour === void 0) { drawContour = false; }\n    if (foregroundIds === void 0) { foregroundIds = [1]; }\n    if (Array.isArray(personOrPartSegmentation) &&\n        personOrPartSegmentation.length === 0) {\n        return null;\n    }\n    var multiPersonOrPartSegmentation;\n    if (!Array.isArray(personOrPartSegmentation)) {\n        multiPersonOrPartSegmentation = [personOrPartSegmentation];\n    }\n    else {\n        multiPersonOrPartSegmentation = personOrPartSegmentation;\n    }\n    var _a = multiPersonOrPartSegmentation[0], width = _a.width, height = _a.height;\n    var bytes = new Uint8ClampedArray(width * height * 4);\n    function drawStroke(bytes, row, column, width, radius, color) {\n        if (color === void 0) { color = { r: 0, g: 255, b: 255, a: 255 }; }\n        for (var i = -radius; i <= radius; i++) {\n            for (var j = -radius; j <= radius; j++) {\n                if (i !== 0 && j !== 0) {\n                    var n = (row + i) * width + (column + j);\n                    bytes[4 * n + 0] = color.r;\n                    bytes[4 * n + 1] = color.g;\n                    bytes[4 * n + 2] = color.b;\n                    bytes[4 * n + 3] = color.a;\n                }\n            }\n        }\n    }\n    function isSegmentationBoundary(segmentationData, row, column, width, foregroundIds, radius) {\n        if (foregroundIds === void 0) { foregroundIds = [1]; }\n        if (radius === void 0) { radius = 1; }\n        var numberBackgroundPixels = 0;\n        for (var i = -radius; i <= radius; i++) {\n            var _loop_2 = function (j) {\n                if (i !== 0 && j !== 0) {\n                    var n_1 = (row + i) * width + (column + j);\n                    if (!foregroundIds.some(function (id) { return id === segmentationData[n_1]; })) {\n                        numberBackgroundPixels += 1;\n                    }\n                }\n            };\n            for (var j = -radius; j <= radius; j++) {\n                _loop_2(j);\n            }\n        }\n        return numberBackgroundPixels > 0;\n    }\n    for (var i = 0; i < height; i += 1) {\n        var _loop_1 = function (j) {\n            var n = i * width + j;\n            bytes[4 * n + 0] = background.r;\n            bytes[4 * n + 1] = background.g;\n            bytes[4 * n + 2] = background.b;\n            bytes[4 * n + 3] = background.a;\n            var _loop_3 = function (k) {\n                if (foregroundIds.some(function (id) { return id === multiPersonOrPartSegmentation[k].data[n]; })) {\n                    bytes[4 * n] = foreground.r;\n                    bytes[4 * n + 1] = foreground.g;\n                    bytes[4 * n + 2] = foreground.b;\n                    bytes[4 * n + 3] = foreground.a;\n                    var isBoundary = isSegmentationBoundary(multiPersonOrPartSegmentation[k].data, i, j, width, foregroundIds);\n                    if (drawContour && i - 1 >= 0 && i + 1 < height && j - 1 >= 0 &&\n                        j + 1 < width && isBoundary) {\n                        drawStroke(bytes, i, j, width, 1);\n                    }\n                }\n            };\n            for (var k = 0; k < multiPersonOrPartSegmentation.length; k++) {\n                _loop_3(k);\n            }\n        };\n        for (var j = 0; j < width; j += 1) {\n            _loop_1(j);\n        }\n    }\n    return new ImageData(bytes, width, height);\n}\nexports.toMask = toMask;\nvar RAINBOW_PART_COLORS = [\n    [110, 64, 170], [143, 61, 178], [178, 60, 178], [210, 62, 167],\n    [238, 67, 149], [255, 78, 125], [255, 94, 99], [255, 115, 75],\n    [255, 140, 56], [239, 167, 47], [217, 194, 49], [194, 219, 64],\n    [175, 240, 91], [135, 245, 87], [96, 247, 96], [64, 243, 115],\n    [40, 234, 141], [28, 219, 169], [26, 199, 194], [33, 176, 213],\n    [47, 150, 224], [65, 125, 224], [84, 101, 214], [99, 81, 195]\n];\nfunction toColoredPartMask(partSegmentation, partColors) {\n    if (partColors === void 0) { partColors = RAINBOW_PART_COLORS; }\n    if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n        return null;\n    }\n    var multiPersonPartSegmentation;\n    if (!Array.isArray(partSegmentation)) {\n        multiPersonPartSegmentation = [partSegmentation];\n    }\n    else {\n        multiPersonPartSegmentation = partSegmentation;\n    }\n    var _a = multiPersonPartSegmentation[0], width = _a.width, height = _a.height;\n    var bytes = new Uint8ClampedArray(width * height * 4);\n    for (var i = 0; i < height * width; ++i) {\n        var j = i * 4;\n        bytes[j + 0] = 255;\n        bytes[j + 1] = 255;\n        bytes[j + 2] = 255;\n        bytes[j + 3] = 255;\n        for (var k = 0; k < multiPersonPartSegmentation.length; k++) {\n            var partId = multiPersonPartSegmentation[k].data[i];\n            if (partId !== -1) {\n                var color = partColors[partId];\n                if (!color) {\n                    throw new Error(\"No color could be found for part id \" + partId);\n                }\n                bytes[j + 0] = color[0];\n                bytes[j + 1] = color[1];\n                bytes[j + 2] = color[2];\n                bytes[j + 3] = 255;\n            }\n        }\n    }\n    return new ImageData(bytes, width, height);\n}\nexports.toColoredPartMask = toColoredPartMask;\nvar CANVAS_NAMES = {\n    blurred: 'blurred',\n    blurredMask: 'blurred-mask',\n    mask: 'mask',\n    lowresPartMask: 'lowres-part-mask',\n};\nfunction drawMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var _a = util_1.getInputSize(image), height = _a[0], width = _a[1];\n    canvas.width = width;\n    canvas.height = height;\n    var ctx = canvas.getContext('2d');\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    ctx.drawImage(image, 0, 0);\n    ctx.globalAlpha = maskOpacity;\n    if (maskImage) {\n        assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n        var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n        var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n        ctx.drawImage(blurredMask, 0, 0, width, height);\n    }\n    ctx.restore();\n}\nexports.drawMask = drawMask;\nfunction drawPixelatedMask(canvas, image, maskImage, maskOpacity, maskBlurAmount, flipHorizontal, pixelCellWidth) {\n    if (maskOpacity === void 0) { maskOpacity = 0.7; }\n    if (maskBlurAmount === void 0) { maskBlurAmount = 0; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    if (pixelCellWidth === void 0) { pixelCellWidth = 10.0; }\n    var _a = util_1.getInputSize(image), height = _a[0], width = _a[1];\n    assertSameDimensions({ width: width, height: height }, maskImage, 'image', 'mask');\n    var mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n    var blurredMask = drawAndBlurImageOnOffScreenCanvas(mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n    canvas.width = blurredMask.width;\n    canvas.height = blurredMask.height;\n    var ctx = canvas.getContext('2d');\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    var offscreenCanvas = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask);\n    var offscreenCanvasCtx = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = blurredMask.width * (1.0 / pixelCellWidth);\n    offscreenCanvas.height = blurredMask.height * (1.0 / pixelCellWidth);\n    offscreenCanvasCtx.drawImage(blurredMask, 0, 0, blurredMask.width, blurredMask.height, 0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0, 0, canvas.width, canvas.height);\n    for (var i = 0; i < offscreenCanvas.width; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = '#ffffff';\n        ctx.moveTo(pixelCellWidth * i, 0);\n        ctx.lineTo(pixelCellWidth * i, canvas.height);\n        ctx.stroke();\n    }\n    for (var i = 0; i < offscreenCanvas.height; i++) {\n        ctx.beginPath();\n        ctx.strokeStyle = '#ffffff';\n        ctx.moveTo(0, pixelCellWidth * i);\n        ctx.lineTo(canvas.width, pixelCellWidth * i);\n        ctx.stroke();\n    }\n    ctx.globalAlpha = 1.0 - maskOpacity;\n    ctx.drawImage(image, 0, 0, blurredMask.width, blurredMask.height);\n    ctx.restore();\n}\nexports.drawPixelatedMask = drawPixelatedMask;\nfunction createPersonMask(multiPersonSegmentation, edgeBlurAmount) {\n    var backgroundMaskImage = toMask(multiPersonSegmentation, { r: 0, g: 0, b: 0, a: 255 }, { r: 0, g: 0, b: 0, a: 0 });\n    var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n    if (edgeBlurAmount === 0) {\n        return backgroundMask;\n    }\n    else {\n        return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n    }\n}\nfunction drawBokehEffect(canvas, image, multiPersonSegmentation, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var blurredImage = drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n    canvas.width = blurredImage.width;\n    canvas.height = blurredImage.height;\n    var ctx = canvas.getContext('2d');\n    if (Array.isArray(multiPersonSegmentation) &&\n        multiPersonSegmentation.length === 0) {\n        ctx.drawImage(blurredImage, 0, 0);\n        return;\n    }\n    var personMask = createPersonMask(multiPersonSegmentation, edgeBlurAmount);\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    var _a = util_1.getInputSize(image), height = _a[0], width = _a[1];\n    ctx.drawImage(image, 0, 0, width, height);\n    drawWithCompositing(ctx, personMask, 'destination-in');\n    drawWithCompositing(ctx, blurredImage, 'destination-over');\n    ctx.restore();\n}\nexports.drawBokehEffect = drawBokehEffect;\nfunction createBodyPartMask(multiPersonPartSegmentation, bodyPartIdsToMask, edgeBlurAmount) {\n    var backgroundMaskImage = toMask(multiPersonPartSegmentation, { r: 0, g: 0, b: 0, a: 0 }, { r: 0, g: 0, b: 0, a: 255 }, true, bodyPartIdsToMask);\n    var backgroundMask = renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n    if (edgeBlurAmount === 0) {\n        return backgroundMask;\n    }\n    else {\n        return drawAndBlurImageOnOffScreenCanvas(backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n    }\n}\nfunction blurBodyPart(canvas, image, partSegmentation, bodyPartIdsToBlur, backgroundBlurAmount, edgeBlurAmount, flipHorizontal) {\n    if (bodyPartIdsToBlur === void 0) { bodyPartIdsToBlur = [0, 1]; }\n    if (backgroundBlurAmount === void 0) { backgroundBlurAmount = 3; }\n    if (edgeBlurAmount === void 0) { edgeBlurAmount = 3; }\n    if (flipHorizontal === void 0) { flipHorizontal = false; }\n    var blurredImage = drawAndBlurImageOnOffScreenCanvas(image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n    canvas.width = blurredImage.width;\n    canvas.height = blurredImage.height;\n    var ctx = canvas.getContext('2d');\n    if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n        ctx.drawImage(blurredImage, 0, 0);\n        return;\n    }\n    var bodyPartMask = createBodyPartMask(partSegmentation, bodyPartIdsToBlur, edgeBlurAmount);\n    ctx.save();\n    if (flipHorizontal) {\n        flipCanvasHorizontal(canvas);\n    }\n    var _a = util_1.getInputSize(image), height = _a[0], width = _a[1];\n    ctx.drawImage(image, 0, 0, width, height);\n    drawWithCompositing(ctx, bodyPartMask, 'destination-in');\n    drawWithCompositing(ctx, blurredImage, 'destination-over');\n    ctx.restore();\n}\nexports.blurBodyPart = blurBodyPart;\n//# sourceMappingURL=output_rendering_util.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction cpuBlur(canvas, image, blur) {\n    var ctx = canvas.getContext('2d');\n    var sum = 0;\n    var delta = 5;\n    var alphaLeft = 1 / (2 * Math.PI * delta * delta);\n    var step = blur < 3 ? 1 : 2;\n    for (var y = -blur; y <= blur; y += step) {\n        for (var x = -blur; x <= blur; x += step) {\n            var weight = alphaLeft * Math.exp(-(x * x + y * y) / (2 * delta * delta));\n            sum += weight;\n        }\n    }\n    for (var y = -blur; y <= blur; y += step) {\n        for (var x = -blur; x <= blur; x += step) {\n            ctx.globalAlpha = alphaLeft *\n                Math.exp(-(x * x + y * y) / (2 * delta * delta)) / sum * blur;\n            ctx.drawImage(image, x, y);\n        }\n    }\n    ctx.globalAlpha = 1;\n}\nexports.cpuBlur = cpuBlur;\n//# sourceMappingURL=blur.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PART_CHANNELS = [\n    'left_face',\n    'right_face',\n    'left_upper_arm_front',\n    'left_upper_arm_back',\n    'right_upper_arm_front',\n    'right_upper_arm_back',\n    'left_lower_arm_front',\n    'left_lower_arm_back',\n    'right_lower_arm_front',\n    'right_lower_arm_back',\n    'left_hand',\n    'right_hand',\n    'torso_front',\n    'torso_back',\n    'left_upper_leg_front',\n    'left_upper_leg_back',\n    'right_upper_leg_front',\n    'right_upper_leg_back',\n    'left_lower_leg_front',\n    'left_lower_leg_back',\n    'right_lower_leg_front',\n    'right_lower_leg_back',\n    'left_feet',\n    'right_feet'\n];\n//# sourceMappingURL=part_channels.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar version = '2.0.5';\nexports.version = version;\n//# sourceMappingURL=version.js.map"]}